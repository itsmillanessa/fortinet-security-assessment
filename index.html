<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortinet Security Fabric - Cybersecurity Assessment</title>
    <meta name="description" content="Evaluate su postura de seguridad actual y descubra el roadmap personalizado para alcanzar la excelencia en ciberseguridad con Fortinet">
    <meta name="keywords" content="fortinet, cybersecurity, security assessment, firewall, compliance, roadmap">
    
    <!-- Open Graph para compartir en redes sociales -->
    <meta property="og:title" content="Fortinet Security Assessment">
    <meta property="og:description" content="Cybersecurity Maturity Assessment - Fortinet Security Fabric">
    <meta property="og:type" content="website">
    
    <!-- Favicon simple que no cause errores -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E🛡️%3C/text%3E%3C/svg%3E">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .logo-box {
            background: linear-gradient(135deg, #E31E24 0%, #B71C1C 100%);
            border-radius: 15px;
            padding: 12px 20px;
            margin-right: 20px;
            box-shadow: 0 8px 25px rgba(227, 30, 36, 0.3);
        }

        .logo-icon {
            font-size: 32px;
            color: white;
            font-weight: bold;
        }

        .main-title {
            font-size: 36px;
            font-weight: bold;
            color: #1f2937;
            margin: 0;
            line-height: 1.2;
        }

        .subtitle {
            font-size: 18px;
            color: #E31E24;
            font-weight: 600;
            margin-top: 5px;
        }

        .description {
            font-size: 16px;
            color: #6b7280;
            max-width: 600px;
            margin: 0 auto;
        }

        .btn {
            padding: 15px 35px;
            border-radius: 12px;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 8px 8px 0;
            transition: all 0.3s ease;
            display: inline-block;
            text-decoration: none;
            text-align: center;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-primary {
            background: linear-gradient(135deg, #E31E24 0%, #B71C1C 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(227, 30, 36, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #333333 0%, #1a1a1a 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(51, 51, 51, 0.3);
        }

        .btn-gray {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(107, 114, 128, 0.3);
        }

        .trust-indicators {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .trust-item {
            display: flex;
            align-items: center;
            color: #6b7280;
            font-size: 14px;
        }

        .trust-icon {
            color: #E31E24;
            margin-right: 8px;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .card-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 30px;
            text-align: center;
        }

        .grid {
            display: grid;
            gap: 20px;
            margin-bottom: 30px;
        }

        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        }

        .grid-4 {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .industry-card {
            padding: 20px;
            border: 2px solid #e5e7eb;
            border-radius: 15px;
            cursor: pointer;
            background: white;
            transition: all 0.3s ease;
            text-align: center;
        }

        .industry-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .industry-card.selected {
            border: 3px solid #E31E24;
            background: #fef2f2;
        }

        .industry-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .industry-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .industry-frameworks {
            font-size: 12px;
            color: #6b7280;
        }

        .tech-card {
            padding: 20px;
            border: 2px solid #e5e7eb;
            border-radius: 15px;
            cursor: pointer;
            background: white;
            transition: all 0.3s ease;
            position: relative;
        }

        .tech-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .tech-card.implemented {
            border: 3px solid #10b981;
            background: #f0fdf4;
        }

        .tech-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            border: 3px solid #d1d5db;
            background: #f9fafb;
        }

        .tech-category {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #3b82f6;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
        }

        .tech-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .tech-info {
            display: flex;
            align-items: center;
        }

        .tech-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .tech-name {
            font-weight: bold;
            font-size: 16px;
        }

        .tech-status {
            color: #10b981;
            font-size: 20px;
        }

        .tech-desc {
            font-size: 14px;
            color: #6b7280;
            margin: 8px 0;
        }

        .dependencies {
            margin: 10px 0;
        }

        .dep-label {
            font-size: 11px;
            font-weight: bold;
            color: #6b7280;
            margin-bottom: 5px;
        }

        .dep-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .dep-item {
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: bold;
        }

        .dep-item.satisfied {
            background: #dcfce7;
            color: #16a34a;
        }

        .dep-item.missing {
            background: #fef2f2;
            color: #dc2626;
        }

        .tech-impact {
            margin-top: 10px;
            font-size: 12px;
            font-weight: bold;
            color: #3b82f6;
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .filter-btn {
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #e5e7eb;
            background: white;
            color: #6b7280;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-btn.active {
            border: 2px solid #E31E24;
            background: #fef2f2;
            color: #E31E24;
        }

        .button-group {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            text-align: center;
            padding: 30px;
            border-radius: 15px;
        }

        .metric-value {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .metric-label {
            font-size: 14px;
            color: #6b7280;
        }

        .roadmap-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 15px;
            padding: 20px;
            overflow: auto;
        }

        .roadmap-canvas {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }

        .hidden {
            display: none;
        }

        .phase-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .phase-card {
            padding: 15px;
            border-radius: 12px;
            border: 3px solid;
        }

        .phase-card.current {
            opacity: 1;
        }

        .phase-card.inactive {
            opacity: 0.7;
        }

        .phase-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .phase-number {
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
            color: white;
        }

        .phase-name {
            font-weight: bold;
            font-size: 14px;
        }

        .phase-desc {
            font-size: 11px;
            color: #6b7280;
        }

        .current-marker {
            margin-left: auto;
            font-size: 16px;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #6b7280;
        }

        @media (max-width: 768px) {
            .logo-container {
                flex-direction: column;
                text-align: center;
            }

            .logo-box {
                margin-right: 0;
                margin-bottom: 15px;
            }

            .main-title {
                font-size: 28px;
            }

            .btn {
                width: 100%;
                margin: 5px 0;
            }

            .trust-indicators {
                flex-direction: column;
                gap: 15px;
            }

            .button-group {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo-container">
                <div class="logo-box">
                    <span class="logo-icon">🛡️</span>
                </div>
                <div>
                    <h1 class="main-title">Fortinet Security Fabric</h1>
                    <div class="subtitle">Cybersecurity Maturity Assessment</div>
                </div>
            </div>
            <p class="description">
                Evaluate su postura de seguridad actual y descubra el roadmap personalizado para alcanzar la excelencia en ciberseguridad
            </p>
        </div>

        <!-- Homepage -->
        <div id="homepage" class="card">
            <div style="text-align: center; margin: 30px 0;">
                <button class="btn btn-primary" id="start-btn">
                    📊 Iniciar Assessment
                </button>
            </div>
            
            <div class="trust-indicators">
                <div class="trust-item">
                    <span class="trust-icon">🏆</span>
                    #1 en Firewalls Globalmente
                </div>
                <div class="trust-item">
                    <span class="trust-icon">🛡️</span>
                    500,000+ Organizaciones
                </div>
                <div class="trust-item">
                    <span class="trust-icon">⚡</span>
                    Assessment en 5 Minutos
                </div>
            </div>
        </div>

        <!-- Step 1: Industry Selection -->
        <div id="step1" class="card hidden">
            <h2 class="card-title">🏢 Selecciona tu Industria</h2>
            
            <div class="grid grid-2" id="industries-grid">
                <!-- Se llena dinámicamente -->
            </div>

            <div style="text-align: center;">
                <button class="btn btn-primary" id="continue-btn" disabled>
                    Continuar al Assessment →
                </button>
            </div>
        </div>

        <!-- Step 2: Technology Assessment -->
        <div id="step2" class="card hidden">
            <h2 class="card-title">🔍 Assessment del Portafolio Fortinet</h2>

            <!-- Category Filters -->
            <div class="filter-buttons" id="category-filters">
                <!-- Se llena dinámicamente -->
            </div>
            
            <div class="grid grid-3" id="technologies-grid">
                <!-- Se llena dinámicamente -->
            </div>

            <div class="button-group">
                <button class="btn btn-gray" id="back-btn">
                    ← Anterior
                </button>
                <button class="btn btn-primary" id="generate-btn">
                    🚀 Generar Roadmap
                </button>
            </div>
        </div>

        <!-- Step 4: Results -->
        <div id="step4" class="hidden">
            <!-- Overview -->
            <div class="card">
                <h2 class="card-title">🎯 Tu Nivel de Madurez</h2>
                
                <div class="metrics-grid" id="metrics-grid">
                    <!-- Se llena dinámicamente -->
                </div>
            </div>

            <!-- ⭐ ROADMAP VISUAL ELEGANTE ⭐ -->
            <div class="card">
                <h2 class="card-title">🗺️ Roadmap Visual de Madurez en Ciberseguridad</h2>
                
                <div class="roadmap-container">
                    <canvas id="roadmap-canvas" width="1400" height="700" class="roadmap-canvas"></canvas>
                </div>

                <!-- Phase Details -->
                <div class="phase-grid" id="phases-grid">
                    <!-- Se llena dinámicamente -->
                </div>
            </div>

            <!-- Technologies -->
            <div class="grid grid-2">
                <!-- Implemented -->
                <div class="card">
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 20px; color: #10b981;">
                        ✅ Implementadas (<span id="implemented-count">0</span>)
                    </h3>
                    
                    <div id="implemented-list">
                        <!-- Se llena dinámicamente -->
                    </div>
                </div>

                <!-- Missing -->
                <div class="card">
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 20px; color: #E31E24;">
                        🎯 Próximos Pasos (<span id="missing-count">0</span>)
                    </h3>
                    
                    <div id="missing-list">
                        <!-- Se llena dinámicamente -->
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 30px;">
                <button class="btn btn-gray" id="reset-btn">
                    🔄 Nuevo Assessment
                </button>
                <button class="btn btn-primary" id="export-btn">
                    🖼️ Descargar Roadmap
                </button>
                <button class="btn btn-secondary" id="report-btn">
                    📄 Generar Reporte
                </button>
                <button class="btn btn-primary" id="share-btn">
                    🔗 Compartir Resultado
                </button>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <p>© 2025 Fortinet Security Fabric - Cybersecurity Assessment Tool</p>
            <p style="font-size: 14px;">Para más información contacte a su representante Fortinet</p>
        </div>
    </div>

    <script>
        console.log('🚀 Fortinet Assessment - Script iniciado');

        // Data structures
        const industries = {
            financial: { name: 'Servicios Financieros', icon: '🏦', frameworks: ['SOX', 'PCI-DSS', 'NIST', 'ISO27001'] },
            government: { name: 'Gobierno', icon: '🏛️', frameworks: ['NIST', 'FedRAMP', 'FISMA', 'CIS'] },
            healthcare: { name: 'Salud', icon: '🏥', frameworks: ['HIPAA', 'HITECH', 'NIST', 'ISO27001'] },
            retail: { name: 'Retail', icon: '🛒', frameworks: ['PCI-DSS', 'GDPR', 'ISO27001', 'CIS'] },
            manufacturing: { name: 'Manufactura', icon: '🏭', frameworks: ['IEC62443', 'NIST', 'ISO27001', 'CIS'] },
            education: { name: 'Educación', icon: '🎓', frameworks: ['FERPA', 'NIST', 'ISO27001', 'CIS'] }
        };

        const maturityPhases = {
            phase1: { name: "Básico - Protección Fundamental", level: "1.0 - 2.5", color: "#dc2626", bgColor: "#fee2e2", description: "Controles básicos de seguridad", compliance: 25 },
            phase2: { name: "Intermedio - Detección y Respuesta", level: "2.5 - 3.5", color: "#f97316", bgColor: "#fed7aa", description: "Capacidades de detección y análisis", compliance: 60 },
            phase3: { name: "Avanzado - Orquestación Inteligente", level: "3.5 - 4.5", color: "#0891b2", bgColor: "#cffafe", description: "Respuesta automatizada y XDR", compliance: 85 },
            phase4: { name: "Excelencia - Zero Trust & AI", level: "4.5 - 5.0", color: "#059669", bgColor: "#dcfce7", description: "Arquitectura Zero Trust completa", compliance: 100 }
        };

        const technologies = {
            'FortiGate 30G': { icon: '🔥', score: 0.8, desc: 'Next-Generation Firewall de entrada', phase: 'phase1', category: 'Network Security', dependencies: [], enables: ['FortiAnalyzer', 'FortiManager'] },
            'FortiGate 700G': { icon: '⚡', score: 1.8, desc: 'Hybrid Mesh Firewall avanzado', phase: 'phase3', category: 'Network Security', dependencies: [], enables: ['FortiAnalyzer', 'FortiXDR'] },
            'FortiEDR': { icon: '🛡️', score: 1.3, desc: 'Endpoint Detection and Response', phase: 'phase2', category: 'Endpoint Security', dependencies: ['FortiClient EMS'], enables: ['FortiXDR'] },
            'FortiXDR': { icon: '🎯', score: 1.7, desc: 'Extended Detection and Response', phase: 'phase3', category: 'SOC & Analytics', dependencies: ['FortiEDR'], enables: ['FortiSIEM'] },
            'FortiSIEM': { icon: '🔍', score: 1.4, desc: 'Security Information and Event Management', phase: 'phase3', category: 'SOC & Analytics', dependencies: ['FortiAnalyzer'], enables: ['FortiSOAR'] },
            'FortiAnalyzer': { icon: '📊', score: 0.9, desc: 'Security Analytics y Reporting', phase: 'phase2', category: 'SOC & Analytics', dependencies: ['FortiGate 30G'], enables: ['FortiSIEM'] },
            'FortiAuthenticator': { icon: '🔐', score: 0.8, desc: 'Multi-Factor Authentication', phase: 'phase1', category: 'Access Control', dependencies: [], enables: ['FortiNAC'] },
            'FortiNAC': { icon: '🚪', score: 1.2, desc: 'Network Access Control', phase: 'phase2', category: 'Access Control', dependencies: ['FortiAuthenticator'], enables: [] },
            'FortiMail': { icon: '📧', score: 1.0, desc: 'Email Security Gateway', phase: 'phase1', category: 'Email & Web Security', dependencies: [], enables: ['FortiSandbox'] },
            'FortiWeb': { icon: '🌍', score: 1.1, desc: 'Web Application Firewall', phase: 'phase2', category: 'Email & Web Security', dependencies: [], enables: ['FortiSandbox'] },
            'FortiSandbox': { icon: '🧪', score: 1.0, desc: 'Advanced Threat Protection', phase: 'phase2', category: 'Email & Web Security', dependencies: ['FortiMail'], enables: ['FortiXDR'] },
            'FortiClient EMS': { icon: '💻', score: 0.7, desc: 'Endpoint Management Suite', phase: 'phase1', category: 'Endpoint Security', dependencies: [], enables: ['FortiEDR'] },
            'FortiSwitch': { icon: '🔌', score: 0.6, desc: 'Switching Ethernet seguro', phase: 'phase2', category: 'Secure Networking', dependencies: ['FortiGate 30G'], enables: ['FortiNAC'] },
            'FortiAP': { icon: '📶', score: 0.5, desc: 'Wireless Access Points', phase: 'phase2', category: 'Secure Networking', dependencies: ['FortiGate 30G'], enables: ['FortiNAC'] },
            'FortiSASE': { icon: '🌐', score: 1.8, desc: 'Secure Access Service Edge', phase: 'phase4', category: 'SASE & SD-WAN', dependencies: ['FortiGate 700G'], enables: [] },
            'FortiManager': { icon: '⚙️', score: 0.8, desc: 'Centralized Security Management', phase: 'phase2', category: 'Management', dependencies: ['FortiGate 30G'], enables: [] },
            'FortiSOAR': { icon: '🤖', score: 1.3, desc: 'Security Orchestration and Response', phase: 'phase3', category: 'SOC & Analytics', dependencies: ['FortiSIEM'], enables: [] },
            'FortiCWP': { icon: '☁️', score: 1.1, desc: 'Cloud Workload Protection', phase: 'phase3', category: 'Cloud Security', dependencies: [], enables: ['FortiXDR'] }
        };

        // App state
        let currentStep = 0;
        let assessmentData = {
            industry: '',
            frameworks: [],
            techs: {},
            categoryFilter: 'Todas'
        };
        let results = null;

        // Helper functions
        function show(elementId) {
            console.log('📺 Mostrando:', elementId);
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.remove('hidden');
            } else {
                console.error('❌ Elemento no encontrado:', elementId);
            }
        }

        function hide(elementId) {
            console.log('🙈 Ocultando:', elementId);
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.add('hidden');
            }
        }

        function goToStep(step) {
            console.log('📍 Navegando al paso:', step);
            // Hide all steps
            hide('homepage');
            hide('step1');
            hide('step2');
            hide('step4');
            
            // Show current step
            currentStep = step;
            if (step === 0) show('homepage');
            else if (step === 1) show('step1');
            else if (step === 2) show('step2');
            else if (step === 4) show('step4');
        }

        // Navigation functions - SIMPLES Y DIRECTAS
        function startAssessment() {
            console.log('📊 Ejecutando startAssessment()');
            renderIndustries();
            goToStep(1);
        }

        function continueToAssessment() {
            if (!assessmentData.industry) return;
            console.log('➡️ Continuando assessment para:', assessmentData.industry);
            renderTechnologies();
            goToStep(2);
        }

        function resetAssessment() {
            console.log('🔄 Reseteando assessment');
            assessmentData = { industry: '', frameworks: [], techs: {}, categoryFilter: 'Todas' };
            results = null;
            currentStep = 0;
            goToStep(0);
        }

        // Industry selection
        function renderIndustries() {
            console.log('🏭 Renderizando industrias');
            const grid = document.getElementById('industries-grid');
            if (!grid) {
                console.error('❌ Grid de industrias no encontrado');
                return;
            }
            
            grid.innerHTML = '';
            
            Object.entries(industries).forEach(([key, industry]) => {
                const card = document.createElement('div');
                card.className = `industry-card ${assessmentData.industry === key ? 'selected' : ''}`;
                card.onclick = () => selectIndustry(key);
                
                card.innerHTML = `
                    <div class="industry-icon">${industry.icon}</div>
                    <div class="industry-name">${industry.name}</div>
                    <div class="industry-frameworks">Frameworks: ${industry.frameworks.join(', ')}</div>
                `;
                
                grid.appendChild(card);
            });
            
            console.log('✅ Industrias renderizadas:', Object.keys(industries).length);
        }

        function selectIndustry(industryKey) {
            console.log('🏢 Industria seleccionada:', industryKey);
            assessmentData.industry = industryKey;
            assessmentData.frameworks = industries[industryKey].frameworks;
            
            // Update UI
            document.querySelectorAll('.industry-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.industry-card').classList.add('selected');
            
            // Enable continue button
            const continueBtn = document.getElementById('continue-btn');
            continueBtn.disabled = false;
            continueBtn.style.background = 'linear-gradient(135deg, #E31E24 0%, #B71C1C 100%)';
            continueBtn.style.boxShadow = '0 8px 25px rgba(227, 30, 36, 0.3)';
        }

        // Technology assessment
        function renderTechnologies() {
            console.log('🔧 Renderizando tecnologías');
            renderCategoryFilters();
            renderTechGrid();
        }

        function renderCategoryFilters() {
            const container = document.getElementById('category-filters');
            const categories = ['Todas', 'Network Security', 'Endpoint Security', 'Email & Web Security', 'Access Control', 'SOC & Analytics', 'Cloud Security', 'SASE & SD-WAN', 'Management'];
            
            container.innerHTML = '';
            categories.forEach(category => {
                const btn = document.createElement('button');
                btn.className = `filter-btn ${assessmentData.categoryFilter === category ? 'active' : ''}`;
                btn.textContent = category;
                btn.onclick = () => {
                    assessmentData.categoryFilter = category;
                    renderCategoryFilters();
                    renderTechGrid();
                };
                container.appendChild(btn);
            });
        }

        function renderTechGrid() {
            const grid = document.getElementById('technologies-grid');
            grid.innerHTML = '';
            
            Object.entries(technologies)
                .filter(([name, tech]) => 
                    assessmentData.categoryFilter === 'Todas' || 
                    tech.category === assessmentData.categoryFilter
                )
                .forEach(([name, tech]) => {
                    const isImplemented = assessmentData.techs[name];
                    const hasImplementedDependencies = tech.dependencies.every(dep => assessmentData.techs[dep]);
                    const canImplement = tech.dependencies.length === 0 || hasImplementedDependencies;
                    
                    const card = document.createElement('div');
                    card.className = `tech-card ${isImplemented ? 'implemented' : ''} ${!canImplement && !isImplemented ? 'disabled' : ''}`;
                    
                    if (canImplement || isImplemented) {
                        card.onclick = () => toggleTechnology(name);
                    }
                    
                    let dependenciesHTML = '';
                    if (tech.dependencies.length > 0) {
                        const depItems = tech.dependencies.map(dep => 
                            `<span class="dep-item ${assessmentData.techs[dep] ? 'satisfied' : 'missing'}">
                                ${assessmentData.techs[dep] ? '✓' : '○'} ${dep.split(' ')[0]}
                            </span>`
                        ).join('');
                        
                        dependenciesHTML = `
                            <div class="dependencies">
                                <div class="dep-label">Requiere:</div>
                                <div class="dep-list">${depItems}</div>
                            </div>
                        `;
                    }
                    
                    card.innerHTML = `
                        <div class="tech-category">${tech.category}</div>
                        <div class="tech-header">
                            <div class="tech-info">
                                <span class="tech-icon">${tech.icon}</span>
                                <span class="tech-name">${name}</span>
                            </div>
                            ${isImplemented ? '<span class="tech-status">✅</span>' : ''}
                            ${!canImplement && !isImplemented ? '<span style="color: #9ca3af; font-size: 16px;">🔒</span>' : ''}
                        </div>
                        <p class="tech-desc">${tech.desc}</p>
                        ${dependenciesHTML}
                        <div class="tech-impact">Impacto: +${tech.score}</div>
                    `;
                    
                    grid.appendChild(card);
                });
        }

        function toggleTechnology(name) {
            console.log('🔄 Toggle tecnología:', name);
            assessmentData.techs[name] = !assessmentData.techs[name];
            renderTechGrid();
        }

        // Results generation
        function generateResults() {
            console.log('🎯 Generando resultados');
            const implemented = Object.entries(assessmentData.techs)
                .filter(([_, selected]) => selected)
                .map(([name, _]) => ({ name, ...technologies[name] }));
            
            const missing = Object.entries(technologies)
                .filter(([name, _]) => !assessmentData.techs[name])
                .map(([name, tech]) => ({ name, ...tech }))
                .sort((a, b) => b.score - a.score);

            const overallMaturity = calculateMaturityLevel();
            const currentPhase = getCurrentPhase();

            results = {
                implemented,
                missing,
                overallMaturity: Math.round(overallMaturity * 10) / 10,
                currentPhase,
                riskReduction: Math.min(overallMaturity * 17, 85)
            };

            console.log('📊 Resultados generados:', results);
            renderResults();
            goToStep(4);
        }

        function calculateMaturityLevel() {
            const implemented = Object.entries(assessmentData.techs).filter(([_, selected]) => selected).map(([name, _]) => technologies[name]);
            const totalScore = implemented.reduce((sum, tech) => sum + tech.score, 0);
            const maxPossibleScore = Object.values(technologies).reduce((sum, tech) => sum + tech.score, 0);
            return Math.min(5, Math.max(1, (totalScore / maxPossibleScore) * 5));
        }

        function getCurrentPhase() {
            const level = calculateMaturityLevel();
            if (level <= 2.5) return 'phase1';
            if (level <= 3.5) return 'phase2'; 
            if (level <= 4.5) return 'phase3';
            return 'phase4';
        }

        function renderResults() {
            console.log('🎨 Renderizando resultados');
            renderMetrics();
            renderPhases();
            renderImplementedList();
            renderMissingList();
            setTimeout(drawRoadmapElegante, 300);
        }

        function renderMetrics() {
            const grid = document.getElementById('metrics-grid');
            grid.innerHTML = `
                <div class="metric-card" style="background: #dbeafe;">
                    <div class="metric-value" style="color: #3b82f6;">${results.overallMaturity}</div>
                    <div class="metric-label">Nivel Actual</div>
                </div>
                <div class="metric-card" style="background: #dcfce7;">
                    <div class="metric-value" style="color: #10b981;">${results.implemented.length}</div>
                    <div class="metric-label">Implementadas</div>
                </div>
                <div class="metric-card" style="background: #fef3c7;">
                    <div class="metric-value" style="color: #f59e0b;">${assessmentData.frameworks.length}</div>
                    <div class="metric-label">Frameworks</div>
                </div>
                <div class="metric-card" style="background: #fdf4ff;">
                    <div class="metric-value" style="color: #a855f7;">${maturityPhases[results.currentPhase]?.name.split(' - ')[0] || 'Básico'}</div>
                    <div class="metric-label">Fase Actual</div>
                </div>
            `;
        }

        function renderPhases() {
            const grid = document.getElementById('phases-grid');
            grid.innerHTML = '';
            
            Object.entries(maturityPhases).forEach(([phaseKey, phase], index) => {
                const isCurrentPhase = results.currentPhase === phaseKey;
                const card = document.createElement('div');
                card.className = `phase-card ${isCurrentPhase ? 'current' : 'inactive'}`;
                card.style.borderColor = phase.color;
                card.style.background = isCurrentPhase ? phase.bgColor : 'white';
                
                card.innerHTML = `
                    <div class="phase-header">
                        <span class="phase-number" style="background: ${phase.color};">${index + 1}</span>
                        <span class="phase-name" style="color: ${phase.color};">${phase.name.split(' - ')[0]}</span>
                        ${isCurrentPhase ? '<span class="current-marker">📍</span>' : ''}
                    </div>
                    <div class="phase-desc">${phase.description}</div>
                `;
                
                grid.appendChild(card);
            });
        }

        function renderImplementedList() {
            const container = document.getElementById('implemented-list');
            const count = document.getElementById('implemented-count');
            
            count.textContent = results.implemented.length;
            
            if (results.implemented.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #6b7280;">
                        <div style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;">🛡️</div>
                        <p>No tienes tecnologías Fortinet</p>
                    </div>
                `;
            } else {
                container.innerHTML = results.implemented.map(tech => `
                    <div style="border: 2px solid #10b981; border-radius: 12px; padding: 15px; background: #f0fdf4; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 20px; margin-right: 10px;">${tech.icon}</span>
                            <span style="font-weight: bold;">${tech.name}</span>
                        </div>
                        <p style="font-size: 14px; color: #6b7280; margin: 0;">${tech.desc}</p>
                    </div>
                `).join('');
            }
        }

        function renderMissingList() {
            const container = document.getElementById('missing-list');
            const count = document.getElementById('missing-count');
            
            count.textContent = Math.min(results.missing.length, 5);
            
            container.innerHTML = results.missing.slice(0, 5).map((tech, idx) => `
                <div style="border: 2px solid #E31E24; border-radius: 12px; padding: 15px; background: #fef2f2; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 20px; margin-right: 10px;">${tech.icon}</span>
                        <span style="font-weight: bold;">${tech.name}</span>
                        <span style="margin-left: auto; font-size: 12px; background: #E31E24; color: white; padding: 4px 8px; border-radius: 20px;">
                            #${idx + 1}
                        </span>
                    </div>
                    <p style="font-size: 14px; color: #6b7280; margin: 0;">${tech.desc}</p>
                </div>
            `).join('');
        }

        // ⭐⭐⭐ FUNCIÓN PRINCIPAL DEL ROADMAP ELEGANTE ⭐⭐⭐
        function drawRoadmapElegante() {
            console.log('🎨 Dibujando roadmap elegante profesional');
            const canvas = document.getElementById('roadmap-canvas');
            if (!canvas || !results) {
                console.error('❌ Canvas o resultados no disponibles');
                return;
            }

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Limpiar canvas con fondo degradado profesional
            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            bgGradient.addColorStop(0, '#f8fafc');
            bgGradient.addColorStop(0.5, '#ffffff');
            bgGradient.addColorStop(1, '#f1f5f9');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            // Parámetros adaptativos
            const margin = Math.max(width * 0.08, 100);
            const startX = margin;
            const startY = height - margin;
            const endX = width - margin;
            const endY = margin * 1.5;
            
            // Curva principal elegante
            const cp1X = width * 0.25;
            const cp1Y = height - margin * 0.8;
            const cp2X = width * 0.75;
            const cp2Y = margin * 2;

            // Función para calcular punto en la curva Bézier
            const getPointOnCurve = (t) => {
                const x = Math.pow(1-t, 3) * startX + 
                          3 * Math.pow(1-t, 2) * t * cp1X + 
                          3 * (1-t) * Math.pow(t, 2) * cp2X + 
                          Math.pow(t, 3) * endX;
                const y = Math.pow(1-t, 3) * startY + 
                          3 * Math.pow(1-t, 2) * t * cp1Y + 
                          3 * (1-t) * Math.pow(t, 2) * cp2Y + 
                          Math.pow(t, 3) * endY;
                return { x, y };
            };

            // Grid de fondo sutil
            ctx.save();
            ctx.globalAlpha = 0.05;
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x <= width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y <= height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            ctx.restore();

            // Zonas de madurez con degradados
            const phases = Object.entries(maturityPhases);
            phases.forEach(([phaseKey, phase], idx) => {
                const phaseStartProgress = idx / phases.length;
                const phaseEndProgress = (idx + 1) / phases.length;
                
                const zoneStartX = startX + (endX - startX) * phaseStartProgress;
                const zoneEndX = startX + (endX - startX) * phaseEndProgress;
                const zoneWidth = zoneEndX - zoneStartX;
                
                // Gradiente vertical para cada zona
                const zoneGradient = ctx.createLinearGradient(0, endY, 0, startY);
                zoneGradient.addColorStop(0, phase.color + '20');
                zoneGradient.addColorStop(0.3, phase.color + '15');
                zoneGradient.addColorStop(0.7, phase.color + '10');
                zoneGradient.addColorStop(1, phase.color + '05');
                
                ctx.fillStyle = zoneGradient;
                ctx.fillRect(zoneStartX, endY - 80, zoneWidth, startY - endY + 160);
                
                // Línea divisoria sutil
                if (idx < phases.length - 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = phase.color;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([15, 8]);
                    ctx.beginPath();
                    ctx.moveTo(zoneEndX, endY - 60);
                    ctx.lineTo(zoneEndX, startY + 60);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
                
                // Etiqueta de fase mejorada
                const centerX = (zoneStartX + zoneEndX) / 2;
                
                // Fondo para etiqueta con sombra
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 3;
                
                ctx.fillStyle = phase.color + '25';
                ctx.fillRect(centerX - 70, endY - 55, 140, 35);
                ctx.strokeStyle = phase.color;
                ctx.lineWidth = 3;
                ctx.strokeRect(centerX - 70, endY - 55, 140, 35);
                ctx.restore();
                
                // Texto de fase
                ctx.fillStyle = phase.color;
                ctx.font = `bold ${Math.max(width * 0.014, 14)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(phase.name.split(' - ')[0], centerX, endY - 40);
                
                ctx.font = `${Math.max(width * 0.011, 11)}px Arial`;
                ctx.fillStyle = '#64748b';
                ctx.fillText(`Nivel ${phase.level}`, centerX, endY - 26);
            });

            // Línea base con sombra elegante
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            
            const baseGradient = ctx.createLinearGradient(startX, startY, endX, endY);
            baseGradient.addColorStop(0, '#e2e8f0');
            baseGradient.addColorStop(0.5, '#cbd5e1');
            baseGradient.addColorStop(1, '#94a3b8');
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);
            ctx.strokeStyle = baseGradient;
            ctx.lineWidth = Math.max(width * 0.01, 10);
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.restore();

            // Progreso actual con efectos
            const currentLevel = calculateMaturityLevel();
            const currentProgress = Math.min((currentLevel - 1) / 4, 1);
            const currentPoint = getPointOnCurve(currentProgress);

            // Línea de progreso con gradiente animado
            ctx.save();
            ctx.shadowColor = 'rgba(16, 185, 129, 0.4)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 3;

            const progressGradient = ctx.createLinearGradient(startX, startY, currentPoint.x, currentPoint.y);
            progressGradient.addColorStop(0, '#10b981');
            progressGradient.addColorStop(0.5, '#3b82f6');
            progressGradient.addColorStop(1, '#8b5cf6');
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            if (currentProgress > 0) {
                ctx.bezierCurveTo(
                    startX + (cp1X - startX) * currentProgress,
                    startY + (cp1Y - startY) * currentProgress,
                    startX + (cp2X - startX) * currentProgress,
                    startY + (cp2Y - startY) * currentProgress,
                    currentPoint.x, currentPoint.y
                );
            }
            ctx.strokeStyle = progressGradient;
            ctx.lineWidth = Math.max(width * 0.015, 15);
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.restore();

            // ⭐ DISTRIBUCIÓN ELEGANTE DE TECNOLOGÍAS ⭐
            const allTechnologies = Object.entries(technologies).map(([name, tech]) => ({
                name, 
                ...tech,
                isImplemented: results.implemented.some(impl => impl.name === name)
            }));

            // Organizar por fase con espaciado inteligente
            const techsByPhase = { phase1: [], phase2: [], phase3: [], phase4: [] };
            allTechnologies.forEach(tech => {
                if (techsByPhase[tech.phase]) {
                    techsByPhase[tech.phase].push(tech);
                }
            });

            // Distribuir tecnologías a lo largo de la curva
            let globalTechIndex = 0;
            const totalTechs = allTechnologies.length;

            Object.entries(techsByPhase).forEach(([phaseKey, techs], phaseIndex) => {
                if (techs.length === 0) return;

                techs.forEach((tech, techIndex) => {
                    // Posición en la curva principal basada en la fase
                    const phaseProgress = (phaseIndex + 0.2 + (techIndex / techs.length) * 0.6) / 4;
                    const curvePoint = getPointOnCurve(phaseProgress);
                    
                    // Distribución vertical elegante - alternando arriba y abajo
                    const isAbove = globalTechIndex % 2 === 0;
                    const verticalOffset = Math.max(width * 0.15, 150);
                    const horizontalOffset = (globalTechIndex % 6 - 2.5) * 15; // Más variedad horizontal
                    
                    const techX = curvePoint.x + horizontalOffset;
                    const techY = curvePoint.y + (isAbove ? -verticalOffset : verticalOffset);
                    
                    // Línea conectora elegante
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    const connectionGradient = ctx.createLinearGradient(curvePoint.x, curvePoint.y, techX, techY);
                    connectionGradient.addColorStop(0, tech.isImplemented ? '#10b981' : '#94a3b8');
                    connectionGradient.addColorStop(1, tech.isImplemented ? '#10b98140' : '#94a3b840');
                    
                    ctx.beginPath();
                    ctx.moveTo(curvePoint.x, curvePoint.y);
                    
                    // Curva suave en lugar de línea recta
                    const midX = (curvePoint.x + techX) / 2;
                    const midY = (curvePoint.y + techY) / 2 + (isAbove ? -30 : 30);
                    ctx.quadraticCurveTo(midX, midY, techX, techY);
                    
                    ctx.strokeStyle = connectionGradient;
                    ctx.lineWidth = Math.max(width * 0.004, 4);
                    ctx.setLineDash([12, 6]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();

                    // Círculo principal con diseño corporativo
                    const circleRadius = Math.max(width * 0.035, 35);
                    
                    // Sombra profesional
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 8;
                    
                    // Círculo base
                    ctx.beginPath();
                    ctx.arc(techX, techY, circleRadius, 0, 2 * Math.PI);
                    
                    // Gradiente corporativo
                    const techGradient = ctx.createRadialGradient(
                        techX - circleRadius/3, techY - circleRadius/3, 0,
                        techX, techY, circleRadius
                    );
                    
                    if (tech.isImplemented) {
                        techGradient.addColorStop(0, '#ffffff');
                        techGradient.addColorStop(0.3, '#10b981');
                        techGradient.addColorStop(1, '#047857');
                    } else {
                        techGradient.addColorStop(0, '#ffffff');
                        techGradient.addColorStop(0.3, '#6b7280');
                        techGradient.addColorStop(1, '#374151');
                    }
                    
                    ctx.fillStyle = techGradient;
                    ctx.fill();
                    ctx.restore();
                    
                    // Borde elegante con brillo
                    ctx.beginPath();
                    ctx.arc(techX, techY, circleRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = tech.isImplemented ? '#10b981' : '#6b7280';
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    
                    // Borde interior brillante
                    ctx.beginPath();
                    ctx.arc(techX, techY, circleRadius - 3, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Icono de tecnología
                    ctx.fillStyle = tech.isImplemented ? '#ffffff' : '#f8fafc';
                    ctx.font = `bold ${Math.max(width * 0.022, 22)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(tech.icon, techX, techY);
                    
                    // Etiqueta profesional
                    const labelY = techY + (isAbove ? circleRadius + 45 : -circleRadius - 45);
                    const fontSize = Math.max(width * 0.012, 12);
                    ctx.font = `bold ${fontSize}px Arial`;
                    const techName = tech.name.length > 15 ? tech.name.substring(0, 13) + '...' : tech.name;
                    const textWidth = ctx.measureText(techName).width;
                    const padding = 10;
                    const labelWidth = textWidth + (padding * 2);
                    const labelHeight = fontSize + 10;
                    
                    // Fondo de etiqueta con sombra
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetY = 3;
                    
                    const labelGradient = ctx.createLinearGradient(0, labelY - labelHeight/2, 0, labelY + labelHeight/2);
                    if (tech.isImplemented) {
                        labelGradient.addColorStop(0, 'rgba(16, 185, 129, 0.95)');
                        labelGradient.addColorStop(1, 'rgba(4, 120, 87, 0.95)');
                    } else {
                        labelGradient.addColorStop(0, 'rgba(107, 114, 128, 0.95)');
                        labelGradient.addColorStop(1, 'rgba(55, 65, 81, 0.95)');
                    }
                    
                    ctx.fillStyle = labelGradient;
                    ctx.fillRect(techX - labelWidth/2, labelY - labelHeight/2, labelWidth, labelHeight);
                    ctx.restore();
                    
                    // Borde de etiqueta
                    ctx.strokeStyle = tech.isImplemented ? '#10b981' : '#6b7280';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(techX - labelWidth/2, labelY - labelHeight/2, labelWidth, labelHeight);
                    
                    // Texto de nombre
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(techName, techX, labelY);
                    
                    // Subtítulo con categoría
                    const categoryY = labelY + (isAbove ? labelHeight/2 + 15 : -labelHeight/2 - 15);
                    ctx.font = `${Math.max(width * 0.009, 9)}px Arial`;
                    ctx.fillStyle = tech.isImplemented ? '#10b981' : '#6b7280';
                    const shortCategory = tech.category.length > 12 ? tech.category.substring(0, 10) + '..' : tech.category;
                    ctx.fillText(shortCategory, techX, categoryY);
                    
                    // Indicador de estado
                    const statusY = techY + (isAbove ? -circleRadius - 18 : circleRadius + 18);
                    
                    if (tech.isImplemented) {
                        // Checkmark verde brillante
                        ctx.save();
                        ctx.shadowColor = 'rgba(16, 185, 129, 0.6)';
                        ctx.shadowBlur = 8;
                        
                        ctx.fillStyle = '#10b981';
                        ctx.beginPath();
                        ctx.arc(techX + circleRadius - 10, statusY, 10, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `bold ${Math.max(width * 0.01, 10)}px Arial`;
                        ctx.fillText('✓', techX + circleRadius - 10, statusY);
                        ctx.restore();
                    } else {
                        // Badge de prioridad para faltantes
                        const missingIndex = results.missing.findIndex(m => m.name === tech.name);
                        if (missingIndex !== -1 && missingIndex < 10) {
                            ctx.save();
                            ctx.shadowColor = 'rgba(220, 38, 38, 0.6)';
                            ctx.shadowBlur = 8;
                            
                            ctx.fillStyle = '#dc2626';
                            ctx.beginPath();
                            ctx.arc(techX + circleRadius - 10, statusY, 12, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.font = `bold ${Math.max(width * 0.009, 9)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(`${missingIndex + 1}`, techX + circleRadius - 10, statusY);
                            ctx.restore();
                        }
                    }
                    
                    globalTechIndex++;
                });
            });

            // Marcador de posición actual mejorado con animación
            if (currentProgress > 0) {
                ctx.save();
                ctx.shadowColor = 'rgba(220, 38, 38, 0.6)';
                ctx.shadowBlur = 25;
                
                // Anillo exterior pulsante
                const pulseRadius = 35 + Math.sin(Date.now() / 400) * 8;
                ctx.beginPath();
                ctx.arc(currentPoint.x, currentPoint.y, pulseRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 4;
                ctx.globalAlpha = 0.6;
                ctx.stroke();
                
                // Círculo principal brillante
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(currentPoint.x, currentPoint.y, 28, 0, 2 * Math.PI);
                
                const positionGradient = ctx.createRadialGradient(
                    currentPoint.x - 10, currentPoint.y - 10, 0,
                    currentPoint.x, currentPoint.y, 28
                );
                positionGradient.addColorStop(0, '#fca5a5');
                positionGradient.addColorStop(0.7, '#dc2626');
                positionGradient.addColorStop(1, '#991b1b');
                
                ctx.fillStyle = positionGradient;
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 5;
                ctx.stroke();
                ctx.restore();
                
                // Icono brillante
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${Math.max(width * 0.018, 18)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('📍', currentPoint.x, currentPoint.y);
                
                // Etiqueta mejorada con sombra
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 5;
                
                const labelBg = ctx.createLinearGradient(0, currentPoint.y - 60, 0, currentPoint.y - 25);
                labelBg.addColorStop(0, 'rgba(220, 38, 38, 0.95)');
                labelBg.addColorStop(1, 'rgba(220, 38, 38, 0.8)');
                
                ctx.fillStyle = labelBg;
                ctx.fillRect(currentPoint.x - 85, currentPoint.y - 60, 170, 30);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(currentPoint.x - 85, currentPoint.y - 60, 170, 30);
                ctx.restore();
                
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${Math.max(width * 0.014, 14)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('TU POSICIÓN ACTUAL', currentPoint.x, currentPoint.y - 50);
                ctx.font = `bold ${Math.max(width * 0.012, 12)}px Arial`;
                ctx.fillText(`Nivel ${currentLevel.toFixed(1)} / 5.0`, currentPoint.x, currentPoint.y - 35);
            }

            // Marcador de objetivo mejorado
            const targetPoint = getPointOnCurve(1);
            ctx.save();
            ctx.shadowColor = 'rgba(16, 185, 129, 0.6)';
            ctx.shadowBlur = 20;
            
            // Efecto de brillo radiante
            const glowGradient = ctx.createRadialGradient(targetPoint.x, targetPoint.y, 0, targetPoint.x, targetPoint.y, 45);
            glowGradient.addColorStop(0, 'rgba(16, 185, 129, 0.4)');
            glowGradient.addColorStop(1, 'transparent');
            
            ctx.beginPath();
            ctx.arc(targetPoint.x, targetPoint.y, 45, 0, 2 * Math.PI);
            ctx.fillStyle = glowGradient;
            ctx.fill();
            
            // Círculo objetivo
            ctx.beginPath();
            ctx.arc(targetPoint.x, targetPoint.y, 25, 0, 2 * Math.PI);
            
            const targetGradient = ctx.createRadialGradient(
                targetPoint.x - 8, targetPoint.y - 8, 0,
                targetPoint.x, targetPoint.y, 25
            );
            targetGradient.addColorStop(0, '#6ee7b7');
            targetGradient.addColorStop(0.7, '#10b981');
            targetGradient.addColorStop(1, '#047857');
            
            ctx.fillStyle = targetGradient;
            ctx.fill();
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${Math.max(width * 0.016, 16)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🎯', targetPoint.x, targetPoint.y);
            
            // Etiqueta objetivo
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetY = 4;
            
            ctx.fillStyle = 'rgba(16, 185, 129, 0.95)';
            ctx.fillRect(targetPoint.x - 60, targetPoint.y - 50, 120, 25);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(targetPoint.x - 60, targetPoint.y - 50, 120, 25);
            ctx.restore();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${Math.max(width * 0.014, 14)}px Arial`;
            ctx.fillText('EXCELENCIA', targetPoint.x, targetPoint.y - 42);
            ctx.font = `bold ${Math.max(width * 0.011, 11)}px Arial`;
            ctx.fillText('Nivel 5.0', targetPoint.x, targetPoint.y - 30);

            // Título principal con sombra
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            
            ctx.fillStyle = '#E31E24';
            ctx.font = `bold ${Math.max(width * 0.025, 25)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('🛡️ FORTINET SECURITY ROADMAP', width / 2, 50);
            ctx.restore();

            // Subtítulo
            ctx.fillStyle = '#333333';
            ctx.font = `bold ${Math.max(width * 0.018, 18)}px Arial`;
            ctx.fillText(`Journey de Madurez en Ciberseguridad - ${industries[assessmentData.industry]?.name || 'Demo'}`, width / 2, 80);

            // Etiquetas de ejes mejoradas
            ctx.fillStyle = '#374151';
            ctx.font = `bold ${Math.max(width * 0.016, 16)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('EVOLUCIÓN EN EL TIEMPO → MADUREZ TECNOLÓGICA', width / 2, height - 20);
            
            ctx.save();
            ctx.translate(25, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = `bold ${Math.max(width * 0.014, 14)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('↑ CAPACIDAD DE SEGURIDAD', 0, 0);
            ctx.restore();

            // Logo Fortinet profesional con sombra
            ctx.save();
            ctx.shadowColor = 'rgba(220, 38, 38, 0.5)';
            ctx.shadowBlur = 12;
            ctx.fillStyle = '#dc2626';
            ctx.font = `bold ${Math.max(width * 0.022, 22)}px Arial`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('FORTINET SECURITY FABRIC', width - 40, height - 25);
            ctx.restore();

            console.log('✅ Roadmap elegante completado con éxito');
        }

        // Función para exportar roadmap
        function exportRoadmap() {
            const canvas = document.getElementById('roadmap-canvas');
            if (!canvas) {
                alert('❌ Error: No se encontró el roadmap para exportar');
                return;
            }

            try {
                const dataURL = canvas.toDataURL('image/png', 1.0);
                const tempLink = document.createElement('a');
                tempLink.href = dataURL;
                tempLink.download = `Fortinet-Roadmap-${assessmentData.industry || 'assessment'}-${new Date().toISOString().split('T')[0]}.png`;
                
                document.body.appendChild(tempLink);
                tempLink.click();
                document.body.removeChild(tempLink);
                
                alert('🖼️ ¡Roadmap exportado exitosamente!\n\nArchivo: ' + tempLink.download);
            } catch (error) {
                console.error('Error exportando roadmap:', error);
                alert('❌ Error al exportar roadmap. Por favor intenta de nuevo.');
            }
        }

        // Función para generar reporte completo
        function generateReport() {
            if (!results) {
                alert('❌ Error: No hay datos para exportar');
                return;
            }

            try {
                const reportText = `
FORTINET SECURITY ROADMAP REPORT
================================

INFORMACIÓN GENERAL
------------------
Fecha: ${new Date().toLocaleDateString('es-ES')}
Industria: ${industries[assessmentData.industry]?.name || 'Assessment'}
Nivel de Madurez: ${results.overallMaturity}/5.0
Fase Actual: ${maturityPhases[results.currentPhase]?.name || 'Básico'}
Frameworks: ${assessmentData.frameworks.join(', ')}

MÉTRICAS CLAVE
--------------
Tecnologías Implementadas: ${results.implemented.length}/${Object.keys(technologies).length}
Completitud: ${Math.round((results.implemented.length / Object.keys(technologies).length) * 100)}%
Reducción de Riesgo: ${Math.round(results.riskReduction)}%

TECNOLOGÍAS IMPLEMENTADAS
------------------------
${results.implemented.map(t => `• ${t.icon} ${t.name} - ${t.desc}`).join('\n')}

PRÓXIMOS PASOS RECOMENDADOS (Prioridad)
---------------------------------------
${results.missing.slice(0, 10).map((t, i) => `${i+1}. ${t.icon} ${t.name} - ${t.desc} (Impacto: +${t.score})`).join('\n')}

ROADMAP DE IMPLEMENTACIÓN
------------------------
Fase 1 - Básico (Nivel 1.0-2.5):
${Object.entries(technologies).filter(([_, t]) => t.phase === 'phase1').map(([name, t]) => `• ${t.icon} ${name}`).join('\n')}

Fase 2 - Intermedio (Nivel 2.5-3.5):
${Object.entries(technologies).filter(([_, t]) => t.phase === 'phase2').map(([name, t]) => `• ${t.icon} ${name}`).join('\n')}

Fase 3 - Avanzado (Nivel 3.5-4.5):
${Object.entries(technologies).filter(([_, t]) => t.phase === 'phase3').map(([name, t]) => `• ${t.icon} ${name}`).join('\n')}

Fase 4 - Excelencia (Nivel 4.5-5.0):
${Object.entries(technologies).filter(([_, t]) => t.phase === 'phase4').map(([name, t]) => `• ${t.icon} ${name}`).join('\n')}

CONTACTO
--------
Para implementar estas recomendaciones, contacte a su representante Fortinet.
Generado por: Fortinet Security Fabric Assessment Tool
                `;
                
                // Crear blob y descargar
                const blob = new Blob([reportText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const tempLink = document.createElement('a');
                tempLink.href = url;
                tempLink.download = `Fortinet-Report-${assessmentData.industry || 'assessment'}-${new Date().toISOString().split('T')[0]}.txt`;
                
                document.body.appendChild(tempLink);
                tempLink.click();
                document.body.removeChild(tempLink);
                
                // Limpiar URL
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                alert('📄 ¡Reporte generado exitosamente!\n\n• Incluye: Resumen ejecutivo, métricas y roadmap completo\n• Archivo: ' + tempLink.download);
            } catch (error) {
                console.error('Error generando reporte:', error);
                alert('❌ Error al generar reporte. Por favor intenta de nuevo.');
            }
        }

        function shareResults() {
            const url = window.location.href;
            if (navigator.clipboard) {
                navigator.clipboard.writeText(url).then(() => {
                    alert('🔗 ¡URL copiada al portapapeles! Compártela con clientes y equipo.');
                }).catch(() => {
                    alert('🔗 URL para compartir: ' + url);
                });
            } else {
                alert('🔗 URL para compartir: ' + url);
            }
        }

        // INICIALIZACIÓN SIMPLE Y DIRECTA
        document.addEventListener('DOMContentLoaded', function() {
            console.log('📍 DOM Content Loaded');
            
            // Esperar un poco para que los elementos estén listos
            setTimeout(() => {
                console.log('🔧 Configurando botones...');
                
                // Obtener elementos
                const startBtn = document.getElementById('start-btn');
                const continueBtn = document.getElementById('continue-btn');
                const backBtn = document.getElementById('back-btn');
                const generateBtn = document.getElementById('generate-btn');
                const resetBtn = document.getElementById('reset-btn');
                const exportBtn = document.getElementById('export-btn');
                const reportBtn = document.getElementById('report-btn');
                const shareBtn = document.getElementById('share-btn');
                
                // Configurar eventos
                if (startBtn) {
                    startBtn.onclick = startAssessment;
                    console.log('✅ Start button configurado');
                } else {
                    console.error('❌ Start button NO encontrado');
                }
                
                if (continueBtn) {
                    continueBtn.onclick = continueToAssessment;
                    console.log('✅ Continue button configurado');
                }
                
                if (backBtn) {
                    backBtn.onclick = () => goToStep(1);
                    console.log('✅ Back button configurado');
                }
                
                if (generateBtn) {
                    generateBtn.onclick = generateResults;
                    console.log('✅ Generate button configurado');
                }
                
                if (resetBtn) {
                    resetBtn.onclick = resetAssessment;
                    console.log('✅ Reset button configurado');
                }
                
                if (exportBtn) {
                    exportBtn.onclick = exportRoadmap;
                    console.log('✅ Export button configurado');
                }
                
                if (reportBtn) {
                    reportBtn.onclick = generateReport;
                    console.log('✅ Report button configurado');
                }
                
                if (shareBtn) {
                    shareBtn.onclick = shareResults;
                    console.log('✅ Share button configurado');
                }
                
                console.log('🎉 Todos los botones configurados');
                
                // Test del botón principal
                if (startBtn) {
                    console.log('🧪 Botón start listo para funcionar');
                }
            }, 500); // Esperar 500ms para que todo esté listo
        });

        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('💥 ERROR:', e.message, 'en', e.filename, 'línea', e.lineno);
        });
    </script>
</body>
</html>
